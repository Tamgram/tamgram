import Fun_symbols
open Fun_symbols

apred SupplicantReceivesM1 (
  named suppThreadID,
  named suppID,
  named PMK,
  named authThreadID,
  named PTK,
  named GTK,
  named ANonce,
  named SNonce,
  named ctr_m1,
)

apred SupplicantSeesCounter (
  named suppThreadID,
  named PMK,
  named ctr,
)

apred SupplicantReceivesM1Again (
  named suppThreadID,
  named suppID,
  named PMK,
  named authThreadID,
  named PTK,
  named GTK,
  named ANonce,
  named SNonce,
  named ctr,
)

apred SupplicantReceivesM3 (
  named suppThreadID,
  named suppID,
  named PMK,
  named authThreadID,
  named PTK,
  named GTK,
  named ANonce,
  named SNonce,
  named ctr,
)

apred SupplicantReceivesM3Again (
  named suppThreadID,
  named suppID,
  named PMK,
  named authThreadID,
  named PTK,
  named GTK,
  named ANonce,
  named SNonce,
  named ctr,
)

apred SupplicantGroupKeyRekey (
  named suppThreadID,
  named suppID,
  named PMK,
  named authThreadID,
  named PTK,
  named oldGTK,
  named newGTK,
  named ANonce,
  named SNonce,
  named ctr,
)

pred !PairwiseMasterKey (
  named PMK,
  named authID,
  named authThreadID,
  named suppID,
  named suppThreadID,
)

apred AuthenticatorSendsM1Again (
  named authThreadID,
  named authID,
  named PMK,
  named suppThreadID,
  named PTK,
  named ANonce,
  named SNonce,
  named ctr,
)

equation sndec =
  All message key nonce .
    sndec(snenc(message, key, nonce), key) = message

module Restrictions = {
  restriction Neq =
      All x y #i. Neq(x, y) @ i ==> not(x = y)

  restriction Equality =
      All x y #i. Eq(x,y) @ i ==> x = y

  // According to the standard, the supplicant only accepts messages 1 and 3 if 
  // it hasn't seen their replay counters before.
  restriction ReplayCounterM1 =
       All suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m1 #i.
       SupplicantReceivesM1(suppThreadID, suppID, PMK, authThreadID, PTK, 
                            GTK, ANonce, SNonce, ctr_m1) @ i
       ==> not Ex #j. j < i & 
                      SupplicantSeesCounter(suppThreadID, PMK, ctr_m1) @ j

  restriction ReplayCounterM1Again =
     All suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m1 #i.
     SupplicantReceivesM1Again(suppThreadID, suppID, PMK, authThreadID, PTK, 
                                 GTK, ANonce, SNonce, ctr_m1) @ i
       ==> not Ex #j. j < i & 
                      SupplicantSeesCounter(suppThreadID, PMK, ctr_m1) @ j

  restriction ReplayCounterM3 =
       All suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr_m3 #i.
       SupplicantReceivesM3(suppThreadID, suppID, PMK, authThreadID, PTK, 
                            GTK, ANonce, SNonce, ctr_m3) @ i
       ==> not Ex #j. j < i & 
                      SupplicantSeesCounter(suppThreadID, PMK, ctr_m3) @ j

  restriction ReplayCounterM3Again =
       All suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m3 #i.
       SupplicantReceivesM3Again(suppThreadID, suppID, PMK, authThreadID, PTK, 
                                 GTK, ANonce, SNonce, ctr_m3) @ i
       ==> not Ex #j. j < i & 
                      SupplicantSeesCounter(suppThreadID, PMK, ctr_m3) @ j

  restriction ReplayCounterGroupKeyRekey =
       All suppThreadID suppID PMK authThreadID PTK oldGTK newGTK ANonce SNonce ctr #i.
       SupplicantGroupKeyRekey(suppThreadID, suppID, PMK, authThreadID, PTK, 
                               oldGTK, newGTK, ANonce, SNonce, ctr) @ i
       ==> not Ex #j. j < i & 
                      SupplicantSeesCounter(suppThreadID, PMK, ctr) @ j

  restriction ReplayCounterPairwiseMessages =
       All ptkID receiverThreadID senderID PTK n1 n2 frameType #i #j.
       SeesNonceForPTK(ptkID, receiverThreadID, PTK, 
                       <N(n1), senderID, frameType>) @ i &
       SeesNonceForPTK(ptkID, receiverThreadID, PTK, 
                       <N(n2), senderID, frameType>) @ j & 
       i < j
       ==>  Ex z. n1 + z = n2

  restriction ReplayCounterGroupPayload =
       All keyID receiverThreadID senderID groupKey n1 n2 #i #j.
       SeesNonceForGTK(keyID, receiverThreadID, groupKey, <N(n1), senderID>) @ i &
       SeesNonceForGTK(keyID, receiverThreadID, groupKey, <N(n2), senderID>) @ j & 
       i < j
       ==>  Ex z. n1 + z = n2

  restriction MemoryCanBeFreedOnlyOnce =
      All pointer #i #j. Free(pointer) @ i & Free(pointer) @ j ==> #i = #j

  restriction FreedMemoryCannotBeAccessed =
      All pointer #i #j. Read(pointer) @ i & Free(pointer) @ j ==> i < j 

  restriction FreedUniqueMemoryCannotBeAccessed =
       All pointer owner #i #j. ReadUnique(pointer, owner) @ i & 
       Free(pointer) @ j ==> i < j

  restriction UniqueMemoryMustBeUnique =
       All pointer1 owner #i #j. 
       AllocateUnique(pointer1, owner) @ i &
       ReadUnique(pointer1, owner) @ j
       ==> i < j & 
           not(Ex pointer2 #k. i < k & k < j & 
               AllocateUnique(pointer2, owner) @ k)
}

apred SupplicantCreated/1
pred !Supplicant/1

module Setup = {
  process Supp_Create =
      [ Fr(~suppID) ]
    --[ SupplicantCreated(~suppID) ]->
      [ !Supplicant(~suppID)
      , Out(~suppID) ] // We view the ID as the MAC address, so publish it

  process Auth_Create =
      [ Fr(~authID)
      , Fr(~pointerGTKState)
      , Fr(~x) ]
    --
      let gtk4 = GTK(~x) in
      let gtkNonce = <N("1"), ~authID> in
      let gtk4Data = <gtk4, gtkNonce, "4"> in
      let installedGTKData = gtk4Data in
      let shareGTKData = gtk4Data in
      [ AuthenticatorCreated(~authID)
      , AuthenticatorInstalledGTK(~authID, installedGTKData)
      , AuthenticatorSetsShareGTK(~authID, shareGTKData)
      , AllocateUnique(~pointerGTKState, ~authID)
      ]
    ->[ !Authenticator(~authID)
      , !AuthGTKState(~authID, "SETKEYSDONE", installedGTKData, shareGTKData,
                      ~pointerGTKState)
      , AuthInstalledGTK(~authID, installedGTKData)
      , Out(~authID) ]

  process Auth_Associate_With_Supp =
      [ Fr(~PMK)
      , Fr(~authThreadID)
      , Fr(~suppThreadID)
      , Fr(~authReceiverPtkID)
      , Fr(~suppReceiverPtkID)
      , Fr(~pointerAuthPTK)
      , Fr(~pointerSuppPTK)
      , Fr(~nullGTKID)
      , !Authenticator(~authID)
      , !Supplicant(~suppID) ]
    --
      let ctr_start = S("0") in
      let initialPTK = kNullPTK() in
      let initialSuppGTKData = <kNullGTK(), kNullGTKNonce(), kNullGTKIndex()> in
      [ Init(~PMK)
      , Associate(~authID, ~authThreadID, ~suppID, ~suppThreadID, ~PMK) ]->
      [ AuthState(~authThreadID, 'INIT_R1_SA', <~authID, ~PMK, ~suppThreadID, initialPTK, 
                  'NULL_ANonce', 'NULL_SNonce', ctr_start>)
      , SuppState(~suppThreadID, 'INIT_R1_SA', 
                  <~suppID, ~PMK, ~authThreadID, initialPTK, initialSuppGTKData, 
                   'NULL_ANonce', 'NULL_SNonce', S('NULL')>)
      , !PairwiseMasterKey(~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID)
      , !AuthReceiverPTK(~authReceiverPtkID, ~authThreadID, ~authID, initialPTK,
                         ~pointerAuthPTK)
      , !SuppReceiverPTK(~suppReceiverPtkID, ~suppThreadID, ~suppID, initialPTK, 
                         ~pointerSuppPTK)
      , ReceiverGTK(~suppThreadID, ~nullGTKID, ~PMK,
                    kNullGTK, kNullGTKNonce, kNullGTKIndex)
      , Out(~authThreadID)
      , Out(~suppThreadID) ]
}

// BEGIN Encryption Layer

import Encryption_layer
module Enc = Encryption_layer

module Enc_restrictions = {
  restriction MessagesAreSentInEnqueueOrder =
       All senderThreadID messageID1 messageID2 #i1 #j1 #i2 #j2.
       Enc.EnqueueMessage(senderThreadID, messageID1) @ i1 &
       Enc.EnqueueMessage(senderThreadID, messageID2) @ j1 &
       Enc.SendMessage(senderThreadID, messageID1) @ i2 &
       Enc.SendMessage(senderThreadID, messageID2) @ j2 &
       #i1 < #j1
       ==> #i2 < #j2
}

process receiveGTKEncryptedPayload =
    [ In(snenc(<'data', $message>, GTK(x) as GTK, <N(m), senderID> as incomingNonce))
    , ReceiverGTK(~receiverThreadID, ~keyID, ~PMK,
                  GTK(x), <N(n), senderID> as lastNonce, $index) ]
  --
    [ ReceiveGTKEncryptedPayload(~keyID, ~receiverThreadID, ~PMK,
                                  GTK, incomingNonce)
    , SeesNonceForGTK(~keyID, ~receiverThreadID,
                      GTK, incomingNonce)
    , Neq($index, kNullGTKIndex()) ]
  ->
    [ ReceiverGTK(~receiverThreadID, ~keyID, ~PMK, 
                  GTK, incomingNonce, $index) ]

// We have two rules for sending GTK encrypted payloads to distinguish between
// the case where the installed GTK is also the share GTK and the case 
// where the two GTKs are different.
process sendGTKEncryptedPayload_1 =
    [ AuthInstalledGTK(~authID, installedGTKData) 
    , !AuthGTKState(~authID, stateIdentifier, installedGTKData, shareGTKData,
                    ~oldPointerGTKState)
    , Fr(~newPointerGTKState)
    ]
  --
    [ EncryptedWithGTK(~authID, newGTKData, newShareGTKData)
    , AuthenticatorUsesGTK(~authID, newGTKData, shareGTKData)
    , SendGTKEncryptedPayload(~authID, newGTKData, newShareGTKData)
    , AllocateUnique(~newPointerGTKState, ~authID)
    , Free(~oldPointerGTKState)
    ]
  ->
    [ Out(snenc(<'data', $message>, installedGTK, newGTKNonce))
    , AuthInstalledGTK(~authID, newGTKData) 
    , !AuthGTKState(~authID, stateIdentifier, newGTKData, newGTKData, 
                    ~newPointerGTKState)
    ]

process sendGTKEncryptedPayload_2 =
    [ AuthInstalledGTK(~authID, GTK(~x) as installedGTK)
    , !AuthGTKState(~authID, stateIdentifier,
                    <
		     ~authID, GTK(~x),
		     <N(n), ~authID> as installedGTKNonce,
		     $index
		    > as installedGTKData,
		    <shareGTK, shareGTKNonce, $shareIndex> as shareGTKData,
                    ~oldPointerGTKState)
    , Fr(~newPointerGTKState) ]
  --
    let newGTKNonce = <N(n+'1'), ~authID> in
    let newGTKData = <installedGTK, newGTKNonce, $index> in
    [ EncryptedWithGTK(~authID, newGTKData, shareGTKData)
    , AuthenticatorUsesGTK(~authID, newGTKData, shareGTKData)
    , SendGTKEncryptedPayload(~authID, newGTKData, shareGTKData)
    , AllocateUnique(~newPointerGTKState, ~authID)
    , AllocateUnique(~newPointerGTKState, ~authID)
    , Free(~oldPointerGTKState)
    , Neq(installedGTK, shareGTK)
    ]
  ->
    [ Out(snenc(<'data', $message>, installedGTK, newGTKNonce))
    , AuthInstalledGTK(~authID, newGTKData)
    , !AuthGTKState(~authID, stateIdentifier, newGTKData, shareGTKData,
                    ~newPointerGTKState)
    ]

process KeyRevealFromNonceReuse =
    [ In(<snenc(m1, key, nonce), snenc(m2, key, nonce)>)[+] ]
    --[ Neq(m1, m2), NonceReuse(key, nonce) ]->
    [ Out(key) ]

// END Encryption Layer

// BEGIN Reveal Pairwise Master Key

process KeyRevealPMK =
    [ !PairwiseMasterKey(~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID) ]
    --[ RevealPMK(~PMK)
      , RevealPMKFor(~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID) ]->
    [ Out(~PMK) ]

// END Reveal Pairwise Master Key

// BEGIN PTK state machine for the authenticator (R1KH)

process Auth =
  "Adapt from AuthState to cells":
    [ AuthState(~authThreadID, 'INIT_R1_SA' as state,
                <~authID, ~PMK, ~suppThreadID, KDF(<_PMK, _ANonce, _SNonce>) as PTK, oldANonce, oldSNonce, S(_ctr_minus_1) as ctr>) ]
  ->
    [ 'authThreadID := ~authThreadID
    , 'state := state
    , 'authID := authID
    , 'PMK := PMK
    , 'suppThreadID := suppThreadID
    , 'PTK := PTK
    , 'ANonce := ~ANonce
    , 'oldSNonce := oldSNonce
    , 'ctr := ctr
    ];
  loop {
    choice {
      { "Auth_Snd_M1":
          [ 'state cas "INIT_R1_SA"
          , Fr(~ANonce)
          ]
        --
          let ctr_plus_1 = S(ctr) in
          [ AuthenticatorSendsM1(
              authThreadID is '.,
              authID is '.,
              PMK is '.,
              suppThreadID is '.,
              PTK is '.,
              ANonce is '.,
              SNonce is 'oldSNonce,
              ctr is ctr_plus_1
            )
          ]->
          [ 'state := "PTK_START"
          , 'ANonce := ~ANonce
          , 'ctr := ctr_plus_1
          , 'm1 := <ctr_plus_1, ~ANonce>
          , !UsedCounterInPTKHandshake(~authThreadID, ~ANonce, ctr_plus_1) ];
        Enc.OutEnc(
          authThreadID is '.,
          message is 'm1,
          frameTag is kDataFrame(),
        )
      };
      { "Auth_Snd_M1_repeat":
          [ 'state cas "PTK_START" ]
        --
          [ AuthenticatorSendsM1Again(
              authThreadID is ~authThreadID,
              authID is ~authID,
              PMK is ~PMK,
              ~suppThreadID,
              'PTK, 
              ~ANonce,
              oldSNonce,
              ctr is 'ctr,
            )
          ]->
          [ AuthState(~authThreadID, 'PTK_START', 
                      <~authID, ~PMK, ~suppThreadID, PTK, ~ANonce, oldSNonce, ctr_plus_1>)
          , 'm1 := <ctr_plus_1, ~ANonce>
          , !UsedCounterInPTKHandshake(~authThreadID, ~ANonce, ctr_plus_1) ];
        Enc.OutEnc(
          authThreadID is 'authThreadID,
          message is 'm1,
          frameTag is kDataFrame(),
        )
      };
      { "Auth_Rcv_M2":
          [ 'state cas "PTK_START" ]->[];
        Enc.InEnc(
          role is Auth(),
          message is .,
          receiverThreadID is 'authThreadID,
          receiverID is 'authID
        );
          [ 'message cas <<'ctr, SNonce> as m2, mic_m2> ]
        --[ AuthenticatorReceivesM2(
              ~authThreadID,
              ~authID,
              ~PMK,
              ~suppThreadID,
              'PTK, 
              ~ANonce,
              SNonce,
              ctr
            )
          ]->
          [ 'state := "PTK_CALC_NEGOTIATING"
          , 'm2 := m2
          , 'mic_m2 := mic_m2
          , 'SNonce := SNonce
          ]
      };
      { "Auth_Rcv_M2_repeat":
          [ 'state cas "PKT_CALC_NEGOTIATING" ]->[];
        Enc.InEnc(
          role is Auth(),
          message is .,
          receiverThreadID is 'authThreadID,
          receiverID is 'authID
        );
          [ 'm2 cas <_prev_ctr, SNonce>
          , 'message cas <<ctr, SNonce> as m2, mic_m2> ]
        --[ AuthenticatorReceivesM2Again(
              ~authThreadID,
              ~authID,
              ~PMK,
              ~suppThreadID,
              'PTK,
              ~ANonce,
              SNonce,
              ctr is '.
            )
          ]->
          [ 'm2 := m2
          , 'mic_m2 := mic_m2
          , 'SNonce := SNonce
          ]
      };
      { "Auth_Check_MIC_M2_Snd_M3":
          let 
              oldPTK = KDF(<PMK1, ANonce1, SNonce1>)
              newPTK = KDF(<~PMK, ~ANonce, SNonce>)
              groupKey = GTK(~x)
              groupNonce = <N(n), ~authID>
              shareGTKData = <groupKey, groupNonce, $index>
              ctr = S(ctr_minus_1)
              ctr_plus_1 = S(ctr)
              m2 = <ctr, SNonce>
              m3 = <ctr_plus_1, senc(<groupKey, groupNonce, $index>, newPTK)>
          in
          [ 'state cas "PTK_CALC_NEGOTIATING"
          , !AuthGTKState(~authID, stateIdentifier, installedGTKData, shareGTKData,
                          ~pointerGTKState)
          ]
        --
          let newPTK = KDF(<'PMK, 'ANonce, 'SNonce>) in
          [ Eq('mic_m2, MIC(newPTK, 'm2))
          , AuthenticatorSendsInitialM3(
              ~authThreadID,
              ~authID,
              ~PMK,
              ~suppThreadID,
              oldPTK, 
              ~ANonce,
              SNonce,
              ctr_plus_1
            )
          , AuthenticatorRunning(~authThreadID, ~suppThreadID, 
                                   ~PMK, ~ANonce, SNonce, newPTK)
          , AuthenticatorUsesGTK(~authID, installedGTKData, shareGTKData)
          , AuthenticatorSharesGTK(~authThreadID, ~authID, ~PMK, shareGTKData)
          , ReadUnique(~pointerGTKState, ~authID) ]->
          [ AuthState(~authThreadID, 'PTK_CALC_NEGOTIATING3',
                      <~authID, ~PMK, ~suppThreadID, oldPTK, ~ANonce, SNonce, ctr_plus_1>)
          , !UsedCounterInPTKHandshake(~authThreadID, ~ANonce, ctr_plus_1) ];
        Enc.OutEnc(message is <'m3, MIC('newPTK, 'm3)>,
                   authThreadID is '.,
                   frameTag is kDataFrame())

      };
      { "Auth_Snd_M3_repeat":
          [ AuthState(~authThreadID, 'PTK_CALC_NEGOTIATING3', 
                      <~authID, ~PMK, ~suppThreadID, oldPTK, ~ANonce, SNonce, ctr>)
          , !AuthGTKState(~authID, stateIdentifier, installedGTKData, shareGTKData,
                          ~pointerGTKState)[no_precomp] 
          , Fr(~messageID) ]
        --[ AuthenticatorSendsM3Again(~authThreadID, ~authID, ~PMK, ~suppThreadID, oldPTK, 
                                      ~ANonce, SNonce, ctr_plus_1)
          , AuthenticatorUsesGTK(~authID, installedGTKData, shareGTKData)
          , AuthenticatorSharesGTK(~authThreadID, ~authID, ~PMK, shareGTKData)
          , ReadUnique(~pointerGTKState, ~authID) 
          , EnqueueMessage(~authThreadID, ~messageID) ]->
          [ AuthState(~authThreadID, 'PTK_CALC_NEGOTIATING3', 
                      <~authID, ~PMK, ~suppThreadID, oldPTK, ~ANonce, SNonce, ctr_plus_1>)
          , !UsedCounterInPTKHandshake(~authThreadID, ~ANonce, ctr_plus_1)
          , OutEnc(<!<m3, MIC(newPTK, m3)>!>, ~authThreadID, ~messageID, 
                   Auth_Snd_M3_repeat, Auth) ]
      };
    }
  }

/*
rule Auth_Snd_M3_repeat [color=ddb4ff]:
    let 
        oldPTK = KDF(<PMK1, ANonce1, SNonce1>)
        newPTK = KDF(<~PMK, ~ANonce, SNonce>)
        groupKey = GTK(~x)
        groupNonce = <N(n), ~authID>
        shareGTKData = <groupKey, groupNonce, $index>
        ctr = S(ctr_minus_1)
        ctr_plus_1 = S(ctr)
        m3 = <ctr_plus_1, senc(<groupKey, groupNonce, $index>, newPTK)>
    in

OutEncRuleDataFrame(Auth_Snd_M3_repeat, Auth)

rule Auth_Rcv_M4_Install_Key [color=ddb4ff]:
    let 
        oldPTK = KDF(<PMK1, ANonce1, SNonce1>)
        newPTK = KDF(<~PMK, ~ANonce, SNonce>)
        dataFrameNonce = <kPTKNonceStartNumber, ~authID, kDataFrame>
        managementFrameNonce = <kPTKNonceStartNumber, ~authID, kManagementFrame>
        ctr = S(ctr_minus_1)
        fresh_ctr = S(~counter)
        m4 = S(ctr_m4_minus_1)
    in
    [ AuthState(~authThreadID, 'PTK_CALC_NEGOTIATING3', 
                <~authID, ~PMK, ~suppThreadID, oldPTK, ~ANonce, SNonce, ctr>)
    , !AuthReceiverPTK(~oldReceiverPtkID, ~authThreadID, ~authID, oldPTK,
                       ~oldPointerPTK)[no_precomp] 
    , InEnc(<!<m4, mic_m4>!>, ~authThreadID, oldPTK, Auth)[no_precomp, -]
    , !UsedCounterInPTKHandshake(~authThreadID, ~ANonce, m4)[-]
    , Fr(~dataFramePtkID)
    , Fr(~managementFramePtkID)
    , Fr(~newReceiverPtkID)
	, Fr(~gtkID)
    , Fr(~counter)
    , Fr(~newPointerPTK) ]
    --[ AuthenticatorInstalled(~authThreadID, ~authID, ~PMK, ~suppThreadID,
                               newPTK, ~ANonce, SNonce, ctr)
      , AuthenticatorCommit(~authThreadID, ~suppThreadID, 
                            ~PMK, ~ANonce, SNonce, newPTK)
      , AuthInstalledSenderPTK(~dataFramePtkID, ~authThreadID, ~authID, 
                               newPTK, dataFrameNonce)
      , AuthInstalledSenderPTK(~managementFramePtkID, ~authThreadID, ~authID,
                               newPTK, managementFrameNonce)
      , Eq(mic_m4, MIC(newPTK, m4))
      , Free(~oldPointerPTK) ]->
    [ AuthState(~authThreadID, 'PTK_INIT_DONE', 
                <~authID, ~PMK, ~suppThreadID, newPTK, ~ANonce, SNonce, fresh_ctr>)
    , AuthStartWNMSleepModeThread(~authThreadID, ~authID, ~PMK, oldPTK)
    , AuthSenderPTK(~dataFramePtkID, ~authThreadID, ~authID, 
                    newPTK, dataFrameNonce)
    , AuthSenderPTK(~managementFramePtkID, ~authThreadID, ~authID, 
                    newPTK, managementFrameNonce)
    , !AuthReceiverPTK(~newReceiverPtkID, ~authThreadID, ~authID, newPTK, 
                       ~newPointerPTK) ]

rule Auth_Rekey_PTK [color=a333ff]:
     let
        PTK = KDF(<~PMK, ~ANonce, SNonce>)
        ctr = S(ctr_minus_1)
     in
     [ AuthState(~authThreadID, 'PTK_INIT_DONE', 
                 <~authID, ~PMK, ~suppThreadID, PTK, ~ANonce, SNonce, ctr>) ]
     --[ AuthenticatorRekeyPTK(~authThreadID, ~authID, ~PMK, ~suppThreadID, PTK, 
                               ~ANonce, SNonce, ctr) ]->
     [ AuthState(~authThreadID, 'INIT_R1_SA', 
                 <~authID, ~PMK, ~suppThreadID, PTK, ~ANonce, SNonce, ctr>) ]

// END PTK state machine for the authenticator (R1KH)
*/
